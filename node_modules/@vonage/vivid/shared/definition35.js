import { F as FoundationElement, Y as DOM, _ as __decorate, a as attr, n as nullableNumberConverter, o as observable, b as __metadata, h as html, r as registerFactory } from './index.js';
import { B as Button, b as buttonRegistries } from './definition7.js';
import { D as Divider, d as dividerRegistries } from './definition24.js';
import { b as AffixIcon } from './affix.js';
import './focus.js';
import { f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './form-elements.js';
import { S as StartEnd } from './start-end.js';
import { a as applyMixins } from './apply-mixins.js';
import { D as DelegatesARIATextbox } from './text-field2.js';
import { F as FormAssociated } from './form-associated.js';
import { b as keyArrowDown, c as keyArrowUp } from './key-codes.js';
import './es.regexp.to-string.js';
import { S as Shape } from './enums.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

class _NumberField extends FoundationElement {
}
/**
 * A form-associated base class for the {@link @microsoft/fast-foundation#(NumberField:class)} component.
 *
 * @internal
 */
class FormAssociatedNumberField extends FormAssociated(_NumberField) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
    }
}

/**
 * A Number Field Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number | <input type="number" /> element }.
 *
 * @slot start - Content which can be provided before the number field input
 * @slot end - Content which can be provided after the number field input
 * @slot - The default slot for the label
 * @slot step-up-glyph - The glyph for the step up control
 * @slot step-down-glyph - The glyph for the step down control
 * @csspart label - The label
 * @csspart root - The element wrapping the control, including start and end slots
 * @csspart control - The element representing the input
 * @csspart controls - The step up and step down controls
 * @csspart step-up - The step up control
 * @csspart step-down - The step down control
 * @fires input - Fires a custom 'input' event when the value has changed
 * @fires change - Fires a custom 'change' event when the value has changed
 *
 * @public
 */
class NumberField$1 extends FormAssociatedNumberField {
    constructor() {
        super(...arguments);
        /**
         * When true, spin buttons will not be rendered
         * @public
         * @remarks
         * HTML Attribute: autofocus
         */
        this.hideStep = false;
        /**
         * Amount to increment or decrement the value by
         * @public
         * @remarks
         * HTMLAttribute: step
         */
        this.step = 1;
        /**
         * Flag to indicate that the value change is from the user input
         * @internal
         */
        this.isUserInput = false;
    }
    /**
     * Ensures that the max is greater than the min and that the value
     *  is less than the max
     * @param previous - the previous max value
     * @param next - updated max value
     *
     * @internal
     */
    maxChanged(previous, next) {
        var _a;
        this.max = Math.max(next, (_a = this.min) !== null && _a !== void 0 ? _a : next);
        const min = Math.min(this.min, this.max);
        if (this.min !== undefined && this.min !== min) {
            this.min = min;
        }
        this.value = this.getValidValue(this.value);
    }
    /**
     * Ensures that the min is less than the max and that the value
     *  is greater than the min
     * @param previous - previous min value
     * @param next - updated min value
     *
     * @internal
     */
    minChanged(previous, next) {
        var _a;
        this.min = Math.min(next, (_a = this.max) !== null && _a !== void 0 ? _a : next);
        const max = Math.max(this.min, this.max);
        if (this.max !== undefined && this.max !== max) {
            this.max = max;
        }
        this.value = this.getValidValue(this.value);
    }
    /**
     * The value property, typed as a number.
     *
     * @public
     */
    get valueAsNumber() {
        return parseFloat(super.value);
    }
    set valueAsNumber(next) {
        this.value = next.toString();
    }
    /**
     * Validates that the value is a number between the min and max
     * @param previous - previous stored value
     * @param next - value being updated
     * @param updateControl - should the text field be updated with value, defaults to true
     * @internal
     */
    valueChanged(previous, next) {
        this.value = this.getValidValue(next);
        if (next !== this.value) {
            return;
        }
        if (this.control && !this.isUserInput) {
            this.control.value = this.value;
        }
        super.valueChanged(previous, this.value);
        if (previous !== undefined && !this.isUserInput) {
            this.$emit("input");
            this.$emit("change");
        }
        this.isUserInput = false;
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate() {
        super.validate(this.control);
    }
    /**
     * Sets the internal value to a valid number between the min and max properties
     * @param value - user input
     *
     * @internal
     */
    getValidValue(value) {
        var _a, _b;
        let validValue = parseFloat(parseFloat(value).toPrecision(12));
        if (isNaN(validValue)) {
            validValue = "";
        }
        else {
            validValue = Math.min(validValue, (_a = this.max) !== null && _a !== void 0 ? _a : validValue);
            validValue = Math.max(validValue, (_b = this.min) !== null && _b !== void 0 ? _b : validValue).toString();
        }
        return validValue;
    }
    /**
     * Increments the value using the step value
     *
     * @public
     */
    stepUp() {
        const value = parseFloat(this.value);
        const stepUpValue = !isNaN(value)
            ? value + this.step
            : this.min > 0
                ? this.min
                : this.max < 0
                    ? this.max
                    : !this.min
                        ? this.step
                        : 0;
        this.value = stepUpValue.toString();
    }
    /**
     * Decrements the value using the step value
     *
     * @public
     */
    stepDown() {
        const value = parseFloat(this.value);
        const stepDownValue = !isNaN(value)
            ? value - this.step
            : this.min > 0
                ? this.min
                : this.max < 0
                    ? this.max
                    : !this.min
                        ? 0 - this.step
                        : 0;
        this.value = stepDownValue.toString();
    }
    /**
     * Sets up the initial state of the number field
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "number");
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
            DOM.queueUpdate(() => {
                this.focus();
            });
        }
    }
    /**
     * Selects all the text in the number field
     *
     * @public
     */
    select() {
        this.control.select();
        /**
         * The select event does not permeate the shadow DOM boundary.
         * This fn effectively proxies the select event,
         * emitting a `select` event whenever the internal
         * control emits a `select` event
         */
        this.$emit("select");
    }
    /**
     * Handles the internal control's `input` event
     * @internal
     */
    handleTextInput() {
        this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, "");
        this.isUserInput = true;
        this.value = this.control.value;
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
    /**
     * Handles the internal control's `keydown` event
     * @internal
     */
    handleKeyDown(e) {
        const key = e.key;
        switch (key) {
            case keyArrowUp:
                this.stepUp();
                return false;
            case keyArrowDown:
                this.stepDown();
                return false;
        }
        return true;
    }
    /**
     * Handles populating the input field with a validated value when
     *  leaving the input field.
     * @internal
     */
    handleBlur() {
        this.control.value = this.value;
    }
}
__decorate([
    attr({ attribute: "readonly", mode: "boolean" })
], NumberField$1.prototype, "readOnly", void 0);
__decorate([
    attr({ mode: "boolean" })
], NumberField$1.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "hide-step", mode: "boolean" })
], NumberField$1.prototype, "hideStep", void 0);
__decorate([
    attr
], NumberField$1.prototype, "placeholder", void 0);
__decorate([
    attr
], NumberField$1.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "minlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "size", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "step", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "max", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "min", void 0);
__decorate([
    observable
], NumberField$1.prototype, "defaultSlottedNodes", void 0);
applyMixins(NumberField$1, StartEnd, DelegatesARIATextbox);

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n:host {\n  display: inline-block;\n}\n\n.base {\n  --_text-field-gutter: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2.5);\n  --_text-field-icon-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2);\n  display: inline-grid;\n  width: 100%;\n  gap: 4px;\n  grid-template-columns: min-content 1fr max-content;\n}\n.base {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.base.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-firm);\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)).appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--vvd-color-neutral-100);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-600);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base.connotation-success {\n  --_connotation-color-primary: var(--vvd-color-success-500);\n  --_connotation-color-backdrop: var(--vvd-color-success-50);\n  --_connotation-color-intermediate: var(--vvd-color-success-500);\n  --_connotation-color-firm: var(--vvd-color-success-600);\n  --_connotation-color-faint: var(--vvd-color-success-50);\n  --_connotation-color-soft: var(--vvd-color-success-100);\n}\n.base.connotation-alert {\n  --_connotation-color-primary: var(--vvd-color-alert-500);\n  --_connotation-color-backdrop: var(--vvd-color-alert-50);\n  --_connotation-color-intermediate: var(--vvd-color-alert-500);\n  --_connotation-color-firm: var(--vvd-color-alert-600);\n  --_connotation-color-faint: var(--vvd-color-alert-50);\n  --_connotation-color-soft: var(--vvd-color-alert-100);\n}\n.base:not(.connotation-success, .connotation-alert) {\n  --_connotation-color-primary: var(--vvd-color-canvas-text);\n  --_connotation-color-backdrop: var(--vvd-color-canvas);\n  --_connotation-color-intermediate: var(--vvd-color-neutral-500);\n  --_connotation-color-firm: var(--vvd-color-canvas-text);\n  --_connotation-color-faint: var(--vvd-color-neutral-50);\n  --_connotation-color-soft: var(--vvd-color-neutral-100);\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  --_low-ink-color: var(--vvd-color-neutral-600);\n}\n.base.disabled {\n  --_low-ink-color: var(--_appearance-color-text);\n}\n\n.label {\n  color: var(--vvd-color-canvas-text);\n  contain: inline-size;\n  font: var(--vvd-typography-base);\n  grid-column: 1/4;\n  grid-row: 1;\n}\n.char-count + .label {\n  grid-column: 1/3;\n}\n\n.char-count {\n  color: var(--_low-ink-color);\n  font: var(--vvd-typography-base);\n  grid-column: 3/4;\n}\n\n.fieldset {\n  position: relative;\n  display: flex;\n  align-items: center;\n  grid-column: 1/4;\n  transition: color 0.2s;\n  /* Shape */\n}\n.base > .fieldset {\n  block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n}\n.base:not(.shape-pill) .fieldset {\n  border-radius: 6px;\n}\n.base.shape-pill .fieldset {\n  border-radius: 24px;\n}\n\n.control {\n  width: 100%;\n  border: 0 none;\n  appearance: none; /* for box-shadow visibility on IOS */\n  background-color: var(--_appearance-color-fill);\n  block-size: 100%;\n  border-radius: inherit;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n  padding-block: 0;\n  padding-inline-end: var(--_text-field-gutter);\n  padding-inline-start: var(--_text-field-gutter);\n  transition: box-shadow 0.2s, background-color 0.2s;\n}\n.control:disabled {\n  cursor: not-allowed;\n  opacity: 1; /* 2. correct opacity on iOS */\n  -webkit-text-fill-color: var(--_appearance-color-text); /* 1. sets text fill to current `color` for safari */\n}\n.control::placeholder, .control:disabled::placeholder {\n  opacity: 1; /* 2. correct opacity on iOS */\n  -webkit-text-fill-color: var(--_low-ink-color); /* 1. sets text fill to current `color` for safari */\n}\n@supports selector(:focus-visible) {\n  .control:focus {\n    outline: none;\n  }\n}\n\n.icon {\n  position: absolute;\n  z-index: 1;\n  color: var(--_low-ink-color);\n  font-size: var(--_text-field-icon-size);\n  inset-inline-start: var(--_text-field-gutter);\n  line-height: 1;\n}\n.icon + .control {\n  padding-inline-start: calc(var(--_text-field-icon-size) + var(--_text-field-gutter) * 2);\n}\n\n.focus-indicator {\n  --focus-stroke-gap-color: transparent;\n  pointer-events: none;\n}\n.fieldset:not(:focus-visible, :focus-within) > .focus-indicator {\n  display: none;\n}\n\n.control {\n  padding-inline-end: 70px;\n}\n.control::-webkit-outer-spin-button, .control::-webkit-inner-spin-button {\n  appearance: none;\n}\n.control-buttons {\n  position: absolute;\n  z-index: 1;\n  right: 3px;\n  display: flex;\n}\n.readonly .control-buttons, .disabled .control-buttons {\n  pointer-events: none;\n}\n.control-buttons .divider {\n  margin-block: 8px;\n}\n.control-buttons > * {\n  flex-shrink: 0;\n}\n\n.disabled .focus-indicator {\n  display: none;\n  pointer-events: none;\n}";

let NumberField = class NumberField extends NumberField$1 {};
__decorate([attr, __metadata("design:type", String)], NumberField.prototype, "appearance", void 0);
__decorate([attr, __metadata("design:type", String)], NumberField.prototype, "shape", void 0);
__decorate([attr, __metadata("design:type", String)], NumberField.prototype, "autoComplete", void 0);
NumberField = __decorate([formElements], NumberField);
applyMixins(NumberField, AffixIcon, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

let _ = t => t,
  _t,
  _t2,
  _t3;
const ADD = 1;
const SUBTRACT = -1;
const getStateClasses = ({
  errorValidationMessage,
  disabled,
  value,
  readOnly,
  placeholder,
  appearance,
  shape,
  label,
  successText
}) => classNames(['error connotation-alert', Boolean(errorValidationMessage)], ['disabled', disabled], ['has-value', Boolean(value)], ['readonly', readOnly], ['placeholder', Boolean(placeholder)], [`appearance-${appearance}`, Boolean(appearance)], [`shape-${shape}`, Boolean(shape)], ['no-label', !label], ['success connotation-success', !!successText]);
function renderLabel() {
  return html(_t || (_t = _`
	  <label for="control" class="label">
		  ${0}
	  </label>`), x => x.label);
}
function adjustValueByStep(numberField, direction = ADD) {
  numberField.value = (Number(numberField.value) + direction * (numberField.step ? numberField.step : 1)).toString();
}
function setControlButtonShape(numberField) {
  return numberField.shape === Shape.Pill ? Shape.Pill : null;
}
function getTabIndex(numberField) {
  return numberField.disabled || numberField.readOnly ? '-1' : null;
}
function numberControlButtons(context) {
  const buttonTag = context.tagFor(Button);
  const dividerTag = context.tagFor(Divider);
  return html(_t2 || (_t2 = _`
			<div class="control-buttons"
			     ?inert="${0}">
				<${0} id="subtract" icon="minus-line"
					  					aria-controls="control"
					            shape="${0}"
					            size="condensed"
					  					tabindex="${0}"
					            @click="${0}"></${0}>
				<${0} class="divider" orientation="vertical"></${0}>
				<${0} id="add" icon="plus-line"
					  					aria-controls="control"
					            shape="${0}"
					            size="condensed"
					  					tabindex="${0}"
					            @click="${0}"></${0}>
		    </div>
	`), x => x.disabled || x.readOnly, buttonTag, setControlButtonShape, getTabIndex, x => adjustValueByStep(x, SUBTRACT), buttonTag, dividerTag, dividerTag, buttonTag, setControlButtonShape, getTabIndex, x => adjustValueByStep(x), buttonTag);
}
const NumberFieldTemplate = context => {
  const focusTemplate = focusTemplateFactory(context);
  return html(_t3 || (_t3 = _`
	<div class="base ${0}">
    ${0}
    <div class="fieldset">
      <input class="control"
             id="control"
             @input="${0}"
             @change="${0}"
             ?autofocus="${0}"
             ?disabled="${0}"
             list="${0}"
             step="${0}"
             max="${0}"
             min="${0}"
             maxlength="${0}"
             minlength="${0}"
             placeholder="${0}"
             ?readonly="${0}"
             ?required="${0}"
             size="${0}"
             autocomplete="${0}"
             name="${0}"
             ?spellcheck="${0}"
             :value="${0}"
             type="text"
             aria-atomic="${0}"
             aria-busy="${0}"
             aria-controls="${0}"
             aria-current="${0}"
             aria-describedby="${0}"
             aria-details="${0}"
             aria-disabled="${0}"
             aria-errormessage="${0}"
             aria-flowto="${0}"
             aria-haspopup="${0}"
             aria-hidden="${0}"
             aria-invalid="${0}"
             aria-keyshortcuts="${0}"
             aria-label="${0}"
             aria-labelledby="${0}"
             aria-live="${0}"
             aria-owns="${0}"
             aria-relevant="${0}"
             aria-roledescription="${0}"
             ${0}
      />
      ${0}
      ${0}
    </div>
	  ${0}
	  ${0}
	  ${0}
	</div>
`), getStateClasses, when(x => x.label, renderLabel()), x => x.handleTextInput(), x => x.handleChange(), x => x.autofocus, x => x.disabled, x => x.list, x => x.step ? x.step : null, x => x.max, x => x.min, x => x.maxlength, x => x.minlength, x => x.placeholder, x => x.readOnly, x => x.required, x => x.size, x => x.autoComplete, x => x.name, x => x.spellcheck, x => x.value, x => x.ariaAtomic, x => x.ariaBusy, x => x.ariaControls, x => x.ariaCurrent, x => x.ariaDescribedby, x => x.ariaDetails, x => x.ariaDisabled, x => x.ariaErrormessage, x => x.ariaFlowto, x => x.ariaHaspopup, x => x.ariaHidden, x => x.ariaInvalid, x => x.ariaKeyshortcuts, x => x.ariaLabel, x => x.ariaLabelledby, x => x.ariaLive, x => x.ariaOwns, x => x.ariaRelevant, x => x.ariaRoledescription, ref('control'), () => focusTemplate, () => numberControlButtons(context), when(x => {
    var _a;
    return !x.successText && !x.errorValidationMessage && ((_a = x.helperText) === null || _a === void 0 ? void 0 : _a.length);
  }, getFeedbackTemplate('helper', context)), when(x => !x.successText && x.errorValidationMessage, getFeedbackTemplate('error', context)), when(x => x.successText, getFeedbackTemplate('success', context)));
};

const numberFieldDefinition = NumberField.compose({
  baseName: 'number-field',
  template: NumberFieldTemplate,
  styles: css_248z,
  shadowOptions: {
    delegatesFocus: true
  }
});
const numberFieldRegistries = [numberFieldDefinition(), ...buttonRegistries, ...dividerRegistries];
const registerNumberField = registerFactory(numberFieldRegistries);

export { numberFieldRegistries as a, numberFieldDefinition as n, registerNumberField as r };
