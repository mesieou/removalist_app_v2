import { _ as __decorate, a as attr, b as __metadata, h as html, r as registerFactory } from './index.js';
import { f as focusRegistries } from './definition4.js';
import { i as iconRegistries } from './definition3.js';
import { b as AffixIcon, a as affixIconTemplateFactory } from './affix.js';
import './focus.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './form-elements.js';
import { T as TextField$1 } from './text-field2.js';
import { a as applyMixins } from './apply-mixins.js';
import { c as css_248z } from './text-field.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

let TextField = class TextField extends TextField$1 {};
__decorate([attr, __metadata("design:type", String)], TextField.prototype, "appearance", void 0);
__decorate([attr, __metadata("design:type", String)], TextField.prototype, "shape", void 0);
__decorate([attr, __metadata("design:type", String)], TextField.prototype, "autoComplete", void 0);
TextField = __decorate([errorText, formElements], TextField);
applyMixins(TextField, AffixIcon, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

let _ = t => t,
  _t,
  _t2,
  _t3;
const getStateClasses = ({
  errorValidationMessage,
  disabled,
  value,
  readOnly,
  placeholder,
  appearance,
  shape,
  label,
  successText
}) => classNames(['error connotation-alert', Boolean(errorValidationMessage)], ['disabled', disabled], ['has-value', Boolean(value)], ['readonly', readOnly], ['placeholder', Boolean(placeholder)], [`appearance-${appearance}`, Boolean(appearance)], [`shape-${shape}`, Boolean(shape)], ['no-label', !label], ['success connotation-success', Boolean(successText)]);
function renderLabel() {
  return html(_t || (_t = _`
	  <label for="control" class="label">
		  ${0}
	  </label>`), x => x.label);
}
function renderCharCount() {
  return html(_t2 || (_t2 = _`
		<span class="char-count">${0} / ${0}</span>
	`), x => x.value ? x.value.length : 0, x => x.maxlength);
}
const TextfieldTemplate = context => {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html(_t3 || (_t3 = _`
	<div class="base ${0}">
    ${0}
    ${0}
    <div class="fieldset">
      ${0}
      <input class="control"
            id="control"
            @input="${0}"
            @change="${0}"
            ?autofocus="${0}"
            ?disabled="${0}"
            list="${0}"
            maxlength="${0}"
            minlength="${0}"
            pattern="${0}"
            placeholder="${0}"
            ?readonly="${0}"
            ?required="${0}"
            size="${0}"
            autocomplete="${0}"
            name="${0}"
            ?spellcheck="${0}"
            :value="${0}"
            type="${0}"
            aria-atomic="${0}"
            aria-busy="${0}"
            aria-controls="${0}"
            aria-current="${0}"
            aria-describedby="${0}"
            aria-details="${0}"
            aria-disabled="${0}"
            aria-errormessage="${0}"
            aria-flowto="${0}"
            aria-haspopup="${0}"
            aria-hidden="${0}"
            aria-invalid="${0}"
            aria-keyshortcuts="${0}"
            aria-label="${0}"
            aria-labelledby="${0}"
            aria-live="${0}"
            aria-owns="${0}"
            aria-relevant="${0}"
            aria-roledescription="${0}"
            ${0}
      />
      ${0}
    </div>
	  ${0}
	  ${0}
	  ${0}
	</div>`), getStateClasses, when(x => x.charCount && x.maxlength, renderCharCount()), when(x => x.label, renderLabel()), x => affixIconTemplate(x.icon), x => x.handleTextInput(), x => x.handleChange(), x => x.autofocus, x => x.disabled, x => x.list, x => x.maxlength, x => x.minlength, x => x.pattern, x => x.placeholder, x => x.readOnly, x => x.required, x => x.size, x => x.autoComplete, x => x.name, x => x.spellcheck, x => x.value, x => x.type, x => x.ariaAtomic, x => x.ariaBusy, x => x.ariaControls, x => x.ariaCurrent, x => x.ariaDescribedby, x => x.ariaDetails, x => x.ariaDisabled, x => x.ariaErrormessage, x => x.ariaFlowto, x => x.ariaHaspopup, x => x.ariaHidden, x => x.ariaInvalid, x => x.ariaKeyshortcuts, x => x.ariaLabel, x => x.ariaLabelledby, x => x.ariaLive, x => x.ariaOwns, x => x.ariaRelevant, x => x.ariaRoledescription, ref('control'), () => focusTemplate, when(x => {
    var _a;
    return !x.successText && !x.errorValidationMessage && ((_a = x.helperText) === null || _a === void 0 ? void 0 : _a.length);
  }, getFeedbackTemplate('helper', context)), when(x => !x.successText && x.errorValidationMessage, getFeedbackTemplate('error', context)), when(x => x.successText, getFeedbackTemplate('success', context)));
};

const textFieldDefinition = TextField.compose({
  baseName: 'text-field',
  template: TextfieldTemplate,
  styles: css_248z,
  shadowOptions: {
    delegatesFocus: true
  }
});
const textFieldRegistries = [textFieldDefinition(), ...iconRegistries, ...focusRegistries];
const registerTextField = registerFactory(textFieldRegistries);

export { textFieldRegistries as a, registerTextField as r, textFieldDefinition as t };
