import { F as FoundationElement, Y as DOM, _ as __decorate, a as attr, o as observable, b as __metadata, h as html, r as registerFactory } from './index.js';
import { i as iconRegistries } from './definition3.js';
import { f as focusRegistries } from './definition4.js';
import { b as AffixIcon, a as affixIconTemplateFactory } from './affix.js';
import { S as StartEnd } from './start-end.js';
import { D as Direction, g as getDirection } from './direction.js';
import { a as applyMixins } from './apply-mixins.js';
import { i as keyArrowLeft, h as keyArrowRight, e as keySpace, d as keyEnter } from './key-codes.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

/**
 * Menu items roles.
 * @public
 */
const MenuItemRole = {
    /**
     * The menu item has a "menuitem" role
     */
    menuitem: "menuitem",
    /**
     * The menu item has a "menuitemcheckbox" role
     */
    menuitemcheckbox: "menuitemcheckbox",
    /**
     * The menu item has a "menuitemradio" role
     */
    menuitemradio: "menuitemradio",
};
/**
 * @internal
 */
const roleForMenuItem = {
    [MenuItemRole.menuitem]: "menuitem",
    [MenuItemRole.menuitemcheckbox]: "menuitemcheckbox",
    [MenuItemRole.menuitemradio]: "menuitemradio",
};

/**
 * A Switch Custom HTML Element.
 * Implements {@link https://www.w3.org/TR/wai-aria-1.1/#menuitem | ARIA menuitem }, {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemcheckbox | ARIA menuitemcheckbox}, or {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemradio | ARIA menuitemradio }.
 *
 * @slot checked-indicator - The checked indicator
 * @slot radio-indicator - The radio indicator
 * @slot start - Content which can be provided before the menu item content
 * @slot end - Content which can be provided after the menu item content
 * @slot - The default slot for menu item content
 * @slot expand-collapse-indicator - The expand/collapse indicator
 * @slot submenu - Used to nest menu's within menu items
 * @csspart input-container - The element representing the visual checked or radio indicator
 * @csspart checkbox - The element wrapping the `menuitemcheckbox` indicator
 * @csspart radio - The element wrapping the `menuitemradio` indicator
 * @csspart content - The element wrapping the menu item content
 * @csspart expand-collapse-glyph-container - The element wrapping the expand collapse element
 * @csspart expand-collapse - The expand/collapse element
 * @csspart submenu-region - The container for the submenu, used for positioning
 * @fires expanded-change - Fires a custom 'expanded-change' event when the expanded state changes
 * @fires change - Fires a custom 'change' event when a non-submenu item with a role of `menuitemcheckbox`, `menuitemradio`, or `menuitem` is invoked
 *
 * @public
 */
class MenuItem$1 extends FoundationElement {
    constructor() {
        super(...arguments);
        /**
         * The role of the element.
         *
         * @public
         * @remarks
         * HTML Attribute: role
         */
        this.role = MenuItemRole.menuitem;
        /**
         * @internal
         */
        this.hasSubmenu = false;
        /**
         * Track current direction to pass to the anchored region
         *
         * @internal
         */
        this.currentDirection = Direction.ltr;
        this.focusSubmenuOnLoad = false;
        /**
         * @internal
         */
        this.handleMenuItemKeyDown = (e) => {
            if (e.defaultPrevented) {
                return false;
            }
            switch (e.key) {
                case keyEnter:
                case keySpace:
                    this.invoke();
                    return false;
                case keyArrowRight:
                    //open/focus on submenu
                    this.expandAndFocus();
                    return false;
                case keyArrowLeft:
                    //close submenu
                    if (this.expanded) {
                        this.expanded = false;
                        this.focus();
                        return false;
                    }
            }
            return true;
        };
        /**
         * @internal
         */
        this.handleMenuItemClick = (e) => {
            if (e.defaultPrevented || this.disabled) {
                return false;
            }
            this.invoke();
            return false;
        };
        /**
         * @internal
         */
        this.submenuLoaded = () => {
            if (!this.focusSubmenuOnLoad) {
                return;
            }
            this.focusSubmenuOnLoad = false;
            if (this.hasSubmenu) {
                this.submenu.focus();
                this.setAttribute("tabindex", "-1");
            }
        };
        /**
         * @internal
         */
        this.handleMouseOver = (e) => {
            if (this.disabled || !this.hasSubmenu || this.expanded) {
                return false;
            }
            this.expanded = true;
            return false;
        };
        /**
         * @internal
         */
        this.handleMouseOut = (e) => {
            if (!this.expanded || this.contains(document.activeElement)) {
                return false;
            }
            this.expanded = false;
            return false;
        };
        /**
         * @internal
         */
        this.expandAndFocus = () => {
            if (!this.hasSubmenu) {
                return;
            }
            this.focusSubmenuOnLoad = true;
            this.expanded = true;
        };
        /**
         * @internal
         */
        this.invoke = () => {
            if (this.disabled) {
                return;
            }
            switch (this.role) {
                case MenuItemRole.menuitemcheckbox:
                    this.checked = !this.checked;
                    break;
                case MenuItemRole.menuitem:
                    // update submenu
                    this.updateSubmenu();
                    if (this.hasSubmenu) {
                        this.expandAndFocus();
                    }
                    else {
                        this.$emit("change");
                    }
                    break;
                case MenuItemRole.menuitemradio:
                    if (!this.checked) {
                        this.checked = true;
                    }
                    break;
            }
        };
        /**
         * Gets the submenu element if any
         *
         * @internal
         */
        this.updateSubmenu = () => {
            this.submenu = this.domChildren().find((element) => {
                return element.getAttribute("role") === "menu";
            });
            this.hasSubmenu = this.submenu === undefined ? false : true;
        };
    }
    expandedChanged(oldValue) {
        if (this.$fastController.isConnected) {
            if (this.submenu === undefined) {
                return;
            }
            if (this.expanded === false) {
                this.submenu.collapseExpandedItem();
            }
            else {
                this.currentDirection = getDirection(this);
            }
            this.$emit("expanded-change", this, { bubbles: false });
        }
    }
    checkedChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            this.$emit("change");
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
            this.updateSubmenu();
        });
        if (!this.startColumnCount) {
            this.startColumnCount = 1;
        }
        this.observer = new MutationObserver(this.updateSubmenu);
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        this.submenu = undefined;
        if (this.observer !== undefined) {
            this.observer.disconnect();
            this.observer = undefined;
        }
    }
    /**
     * get an array of valid DOM children
     */
    domChildren() {
        return Array.from(this.children).filter(child => !child.hasAttribute("hidden"));
    }
}
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "disabled", void 0);
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "expanded", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "startColumnCount", void 0);
__decorate([
    attr
], MenuItem$1.prototype, "role", void 0);
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "checked", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "submenuRegion", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "hasSubmenu", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "currentDirection", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "submenu", void 0);
applyMixins(MenuItem$1, StartEnd);

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n@supports selector(:focus-visible) {\n  :host(:focus) {\n    outline: none;\n  }\n}\n.base {\n  position: relative;\n  display: flex;\n  box-sizing: border-box;\n  align-items: center;\n  background-color: var(--_appearance-color-fill);\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  gap: 12px;\n  inline-size: 100%;\n  padding-block: 2px;\n  padding-inline: 16px;\n}\n.base {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:active, .active):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-soft);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:not(:disabled, .disabled, :hover, .hover)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-dim);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:hover, .hover) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-pale);\n  --_appearance-color-outline: transparent;\n}\n.base {\n  --_connotation-color-primary: var(--vvd-color-canvas-text);\n  --_connotation-color-primary-text: var(--vvd-color-canvas);\n  --_connotation-color-primary-increment: var(--vvd-color-neutral-800);\n  --_connotation-color-faint: var(--vvd-color-neutral-50);\n  --_connotation-color-soft: var(--vvd-color-neutral-100);\n  --_connotation-color-pale: var(--vvd-color-neutral-300);\n  --_connotation-color-dim: var(--vvd-color-neutral-200);\n}\n.base:not(.two-lines) {\n  min-block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n}\n.base.two-lines {\n  min-block-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) + calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2) - 16)));\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  cursor: pointer;\n}\n.base.disabled {\n  cursor: not-allowed;\n  pointer-events: none;\n}\n\n.focus-indicator {\n  border-radius: 6px;\n}\n:host(:not(:focus-visible)) .focus-indicator {\n  display: none;\n}\n\n.icon {\n  flex-shrink: 0;\n  font-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2);\n  line-height: 1;\n}\n\n.action,\n.decorative {\n  display: flex;\n  place-content: center;\n}\n\n.action {\n  color: var(--_appearance-color-text);\n}\n.base.trailing .action {\n  order: 1;\n  margin-inline-start: auto;\n}\n\n.base:not(.disabled) .decorative {\n  color: var(--vvd-color-neutral-600);\n}\n.base.disabled .decorative {\n  color: var(--vvd-color-neutral-200);\n}\n\n.text {\n  display: flex;\n  overflow: hidden;\n  flex-direction: column;\n}\n\n.text-primary,\n.text-secondary {\n  /* stylelint-disable value-no-vendor-prefix */\n  display: -webkit-box;\n  /* stylelint-enable value-no-vendor-prefix */\n  overflow: hidden;\n  -webkit-box-orient: vertical;\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n}\n\n.text-primary {\n  -webkit-line-clamp: var(--text-primary-line-clamp, 1);\n}\n.base.two-lines .text-primary {\n  font: var(--vvd-typography-base-bold);\n}\n\n.text-secondary {\n  -webkit-line-clamp: var(--text-secondary-line-clamp, 1);\n}\n.base.two-lines .text-secondary {\n  color: var(--vvd-color-neutral-600);\n}";

class MenuItem extends MenuItem$1 {}
__decorate([attr, __metadata("design:type", String)], MenuItem.prototype, "text", void 0);
__decorate([attr({
  attribute: 'text-secondary'
}), __metadata("design:type", String)], MenuItem.prototype, "textSecondary", void 0);
applyMixins(MenuItem, AffixIcon);

let _ = t => t,
  _t,
  _t2,
  _t3,
  _t4,
  _t5,
  _t6,
  _t7,
  _t8;
const getCheckIcon = (affixIconTemplate, x, iconType) => {
  const iconStatus = x.checked ? 'checked' : 'unchecked';
  const icon = `${iconType}-${iconStatus}-line`;
  return affixIconTemplate(icon, x.icon ? 'trailing' : '');
};
const getClasses = ({
  disabled,
  checked,
  expanded,
  role,
  text,
  textSecondary,
  icon
}) => classNames('base', ['disabled', Boolean(disabled)], ['selected', role !== MenuItemRole.menuitem && Boolean(checked)], ['trailing', role !== MenuItemRole.menuitem && Boolean(icon)], ['expanded', Boolean(expanded)], ['item-checkbox', role === MenuItemRole.menuitemcheckbox], ['item-radio', role === MenuItemRole.menuitemradio], ['two-lines', Boolean(text === null || text === void 0 ? void 0 : text.length) && Boolean(textSecondary === null || textSecondary === void 0 ? void 0 : textSecondary.length)]);
const MenuItemTemplate = (context, definition) => {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html(_t || (_t = _`
	<template
		aria-checked="${0}"
		aria-disabled="${0}"
		aria-expanded="${0}"
		@keydown="${0}"
		@click="${0}"
		@mouseover="${0}"
		@mouseout="${0}"
	>
		<div class="${0}">

				${0}
			${0}

			${0}

			${0}

			${0}

			${0}



		</div>
	</template>
	`), x => x.role !== MenuItemRole.menuitem ? x.checked : void 0, x => x.disabled, x => x.expanded, (x, c) => x.handleMenuItemKeyDown(c.event), (x, c) => x.handleMenuItemClick(c.event), (x, c) => x.handleMouseOver(c.event), (x, c) => x.handleMouseOut(c.event), getClasses, when(x => x.hasSubmenu, html(_t2 || (_t2 = _`
								<div
										class="expand-collapse-glyph-container"
								>
										<span class="expand-collapse">
												<slot name="expand-collapse-indicator">
														${0}
												</slot>
										</span>
								</div>
						`), definition.expandCollapseGlyph || '')), () => focusTemplate, when(x => x.role === MenuItemRole.menuitemcheckbox, html(_t3 || (_t3 = _`<span class="action">${0}</span>`), x => getCheckIcon(affixIconTemplate, x, 'checkbox'))), when(x => x.role === MenuItemRole.menuitemradio, html(_t4 || (_t4 = _`<span class="action">${0}</span>`), x => getCheckIcon(affixIconTemplate, x, 'radio'))), when(x => x.icon, html(_t5 || (_t5 = _`<span class="decorative">${0}</span>`), x => affixIconTemplate(x.icon))), when(x => x.text || x.textSecondary, html(_t6 || (_t6 = _`<span class="text">
				${0}
				${0}
			</span>`), when(x => x.text, html(_t7 || (_t7 = _`<span class="text-primary">${0}</span>`), x => x.text)), when(x => x.textSecondary, html(_t8 || (_t8 = _`<span class="text-secondary">${0}</span>`), x => x.textSecondary)))));
};

const menuItemDefinition = MenuItem.compose({
  baseName: 'menu-item',
  template: MenuItemTemplate,
  styles: css_248z
});
const menuItemRegistries = [menuItemDefinition(), ...iconRegistries, ...focusRegistries];
const registerMenuItem = registerFactory(menuItemRegistries);

export { MenuItem$1 as M, MenuItemRole as a, registerMenuItem as b, menuItemDefinition as c, menuItemRegistries as m, roleForMenuItem as r };
