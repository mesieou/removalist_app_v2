import { F as FoundationElement, _ as __decorate, a as attr, n as nullableNumberConverter, o as observable, b as __metadata, h as html, r as registerFactory } from './index.js';
import { i as iconRegistries } from './definition3.js';
import { f as focusRegistries } from './definition4.js';
import './affix.js';
import './focus.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './form-elements.js';
import { D as DelegatesARIATextbox } from './text-field2.js';
import { a as applyMixins } from './apply-mixins.js';
import { F as FormAssociated } from './form-associated.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

class _TextArea extends FoundationElement {
}
/**
 * A form-associated base class for the {@link @microsoft/fast-foundation#(TextArea:class)} component.
 *
 * @internal
 */
class FormAssociatedTextArea extends FormAssociated(_TextArea) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("textarea");
    }
}

/**
 * Resize mode for a TextArea
 * @public
 */
const TextAreaResize = {
    /**
     * No resize.
     */
    none: "none",
    /**
     * Resize vertically and horizontally.
     */
    both: "both",
    /**
     * Resize horizontally.
     */
    horizontal: "horizontal",
    /**
     * Resize vertically.
     */
    vertical: "vertical",
};

/**
 * A Text Area Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea | <textarea> element }.
 *
 * @slot - The default slot for the label
 * @csspart label - The label
 * @csspart root - The element wrapping the control
 * @csspart control - The textarea element
 * @fires change - Emits a custom 'change' event when the textarea emits a change event
 *
 * @public
 */
class TextArea$1 extends FormAssociatedTextArea {
    constructor() {
        super(...arguments);
        /**
         * The resize mode of the element.
         * @public
         * @remarks
         * HTML Attribute: resize
         */
        this.resize = TextAreaResize.none;
        /**
         * Sizes the element horizontally by a number of character columns.
         *
         * @public
         * @remarks
         * HTML Attribute: cols
         */
        this.cols = 20;
        /**
         * @internal
         */
        this.handleTextInput = () => {
            this.value = this.control.value;
        };
    }
    readOnlyChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.readOnly = this.readOnly;
        }
    }
    autofocusChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.autofocus = this.autofocus;
        }
    }
    listChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.setAttribute("list", this.list);
        }
    }
    maxlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.maxLength = this.maxlength;
        }
    }
    minlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.minLength = this.minlength;
        }
    }
    spellcheckChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.spellcheck = this.spellcheck;
        }
    }
    /**
     * Selects all the text in the text area
     *
     * @public
     */
    select() {
        this.control.select();
        /**
         * The select event does not permeate the shadow DOM boundary.
         * This fn effectively proxies the select event,
         * emitting a `select` event whenever the internal
         * control emits a `select` event
         */
        this.$emit("select");
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate() {
        super.validate(this.control);
    }
}
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "readOnly", void 0);
__decorate([
    attr
], TextArea$1.prototype, "resize", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "form" })
], TextArea$1.prototype, "formId", void 0);
__decorate([
    attr
], TextArea$1.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea$1.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea$1.prototype, "minlength", void 0);
__decorate([
    attr
], TextArea$1.prototype, "name", void 0);
__decorate([
    attr
], TextArea$1.prototype, "placeholder", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea$1.prototype, "cols", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea$1.prototype, "rows", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "spellcheck", void 0);
__decorate([
    observable
], TextArea$1.prototype, "defaultSlottedNodes", void 0);
applyMixins(TextArea$1, DelegatesARIATextbox);

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n:host {\n  display: inline-block;\n}\n\n.base {\n  display: inline-grid;\n  width: inherit;\n  grid-template-columns: 1fr;\n  row-gap: 4px;\n}\n.base {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.base.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-firm);\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)).appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--vvd-color-neutral-100);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-600);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base.connotation-success {\n  --_connotation-color-primary: var(--vvd-color-success-500);\n  --_connotation-color-backdrop: var(--vvd-color-success-50);\n  --_connotation-color-intermediate: var(--vvd-color-success-500);\n  --_connotation-color-firm: var(--vvd-color-success-600);\n  --_connotation-color-faint: var(--vvd-color-success-50);\n  --_connotation-color-soft: var(--vvd-color-success-100);\n}\n.base.connotation-alert {\n  --_connotation-color-primary: var(--vvd-color-alert-500);\n  --_connotation-color-backdrop: var(--vvd-color-alert-50);\n  --_connotation-color-intermediate: var(--vvd-color-alert-500);\n  --_connotation-color-firm: var(--vvd-color-alert-600);\n  --_connotation-color-faint: var(--vvd-color-alert-50);\n  --_connotation-color-soft: var(--vvd-color-alert-100);\n}\n.base:not(.connotation-success, .connotation-alert) {\n  --_connotation-color-primary: var(--vvd-color-canvas-text);\n  --_connotation-color-backdrop: var(--vvd-color-canvas);\n  --_connotation-color-intermediate: var(--vvd-color-neutral-500);\n  --_connotation-color-firm: var(--vvd-color-canvas-text);\n  --_connotation-color-faint: var(--vvd-color-neutral-50);\n  --_connotation-color-soft: var(--vvd-color-neutral-100);\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  --_low-ink-color: var(--vvd-color-neutral-600);\n}\n.base.disabled {\n  --_low-ink-color: var(--_appearance-color-text);\n  pointer-events: none;\n}\n\n.label {\n  color: var(--vvd-color-canvas-text);\n  contain: inline-size;\n  font: var(--vvd-typography-base);\n  grid-column: 1/3;\n  grid-row: 1;\n  line-height: 20px;\n}\n\n.control {\n  padding: 8px 16px;\n  border: 0 none;\n  appearance: none; /* for box-shadow visibility on IOS */\n  background-color: var(--_appearance-color-fill);\n  border-radius: 6px;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n  min-block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n  resize: none;\n  transition: box-shadow 0.2s, background-color 0.2s, color 0.2s;\n}\n.control:disabled {\n  cursor: not-allowed;\n  opacity: 1; /* 2. correct opacity on iOS */\n  pointer-events: none;\n  -webkit-text-fill-color: var(--_appearance-color-text); /* 1. sets text fill to current `color` for safari */\n}\n.control::placeholder, .control:disabled::placeholder {\n  opacity: 1; /* 2. correct opacity on iOS */\n  pointer-events: none;\n  -webkit-text-fill-color: var(--_low-ink-color); /* 1. sets text fill to current `color` for safari */\n}\n.control:focus {\n  outline: 2px solid var(--focus-stroke-color, currentColor);\n  outline-offset: -2px;\n}\n:host([resize=both]) .control {\n  resize: both;\n}\n:host([resize=horizontal]) .control {\n  resize: horizontal;\n}\n:host([resize=vertical]) .control {\n  resize: vertical;\n}";

let TextArea = class TextArea extends TextArea$1 {};
__decorate([attr, __metadata("design:type", String)], TextArea.prototype, "wrap", void 0);
TextArea = __decorate([errorText, formElements], TextArea);
applyMixins(TextArea, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

let _ = t => t,
  _t,
  _t2;
const getClasses = ({
  value,
  errorValidationMessage,
  disabled,
  placeholder,
  readOnly,
  successText
}) => classNames('base', ['readonly', readOnly], ['placeholder', Boolean(placeholder)], ['disabled', disabled], ['error connotation-alert', Boolean(errorValidationMessage)], ['has-value', Boolean(value)], ['success connotation-success', !!successText]);
function renderLabel() {
  return html(_t || (_t = _`
	  <label for="control" class="label">
		  ${0}
	  </label>`), x => x.label);
}
const TextAreaTemplate = context => {
  return html(_t2 || (_t2 = _`
	  <div class="${0}">
		  ${0}
			<textarea class="control"
				?autofocus="${0}"
				placeholder="${0}"
				name="${0}"
				maxlength="${0}"
				rows="${0}"
				cols="${0}"
				wrap="${0}"
				?readonly="${0}"
				?disabled="${0}"
				?required="${0}"
				?spellcheck="${0}"
				:value="${0}"
				aria-atomic="${0}"
				aria-busy="${0}"
				aria-controls="${0}"
				aria-current="${0}"
				aria-describedby="${0}"
				aria-details="${0}"
				aria-disabled="${0}"
				aria-errormessage="${0}"
				aria-flowto="${0}"
				aria-haspopup="${0}"
				aria-hidden="${0}"
				aria-invalid="${0}"
				aria-keyshortcuts="${0}"
				aria-label="${0}"
				aria-labelledby="${0}"
				aria-live="${0}"
				aria-owns="${0}"
				aria-relevant="${0}"
				aria-roledescription="${0}"
				@input="${0}"
				@change="${0}"
				${0}
	  >
			</textarea>
		${0}
		${0}
		${0}
	  </div>
	`), getClasses, when(x => x.label, renderLabel()), x => x.autofocus, x => x.placeholder ? x.placeholder : null, x => x.name ? x.name : null, x => x.maxlength ? x.maxlength : null, x => x.rows ? x.rows : null, x => x.cols ? x.cols : null, x => x.wrap ? x.wrap : null, x => x.readOnly, x => x.disabled, x => x.required, x => x.spellcheck, x => x.value, x => x.ariaAtomic, x => x.ariaBusy, x => x.ariaControls, x => x.ariaCurrent, x => x.ariaDescribedby, x => x.ariaDetails, x => x.ariaDisabled, x => x.ariaErrormessage, x => x.ariaFlowto, x => x.ariaHaspopup, x => x.ariaHidden, x => x.ariaInvalid, x => x.ariaKeyshortcuts, x => x.ariaLabel, x => x.ariaLabelledby, x => x.ariaLive, x => x.ariaOwns, x => x.ariaRelevant, x => x.ariaRoledescription, x => x.handleTextInput(), x => x.handleChange(), ref('control'), when(x => {
    var _a;
    return !x.successText && !x.errorValidationMessage && ((_a = x.helperText) === null || _a === void 0 ? void 0 : _a.length);
  }, getFeedbackTemplate('helper', context)), when(x => !x.successText && x.errorValidationMessage, getFeedbackTemplate('error', context)), when(x => x.successText, getFeedbackTemplate('success', context)));
};

const textAreaDefinition = TextArea.compose({
  baseName: 'text-area',
  template: TextAreaTemplate,
  styles: css_248z,
  shadowOptions: {
    delegatesFocus: true
  }
});
const textAreaRegistries = [textAreaDefinition(), ...iconRegistries, ...focusRegistries];
const registerTextArea = registerFactory(textAreaRegistries);

export { textAreaRegistries as a, registerTextArea as r, textAreaDefinition as t };
