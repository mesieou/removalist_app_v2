import { F as FoundationElement, O as Observable, _ as __decorate, o as observable, a as attr, b as __metadata, h as html, r as registerFactory } from './index.js';
import { i as iconRegistries } from './definition3.js';
import { f as focusRegistries } from './definition4.js';
import { A as AffixIconWithTrailing, a as affixIconTemplateFactory } from './affix.js';
import { A as ARIAGlobalStatesAndProperties } from './aria-global.js';
import { S as StartEnd } from './start-end.js';
import { a as applyMixins } from './apply-mixins.js';
import { i as isHTMLElement } from './dom.js';
import { f as focusTemplateFactory } from './focus2.js';
import './form-elements.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

/**
 * Determines if the element is a {@link (ListboxOption:class)}
 *
 * @param element - the element to test.
 * @public
 */
function isListboxOption(el) {
    return (isHTMLElement(el) &&
        (el.getAttribute("role") === "option" ||
            el instanceof HTMLOptionElement));
}
/**
 * An Option Custom HTML Element.
 * Implements {@link https://www.w3.org/TR/wai-aria-1.1/#option | ARIA option }.
 *
 * @slot start - Content which can be provided before the listbox option content
 * @slot end - Content which can be provided after the listbox option content
 * @slot - The default slot for listbox option content
 * @csspart content - Wraps the listbox option content
 *
 * @public
 */
class ListboxOption$1 extends FoundationElement {
    constructor(text, value, defaultSelected, selected) {
        super();
        /**
         * The defaultSelected state of the option.
         * @public
         */
        this.defaultSelected = false;
        /**
         * Tracks whether the "selected" property has been changed.
         * @internal
         */
        this.dirtySelected = false;
        /**
         * The checked state of the control.
         *
         * @public
         */
        this.selected = this.defaultSelected;
        /**
         * Track whether the value has been changed from the initial value
         */
        this.dirtyValue = false;
        if (text) {
            this.textContent = text;
        }
        if (value) {
            this.initialValue = value;
        }
        if (defaultSelected) {
            this.defaultSelected = defaultSelected;
        }
        if (selected) {
            this.selected = selected;
        }
        this.proxy = new Option(`${this.textContent}`, this.initialValue, this.defaultSelected, this.selected);
        this.proxy.disabled = this.disabled;
    }
    /**
     * Updates the ariaChecked property when the checked property changes.
     *
     * @param prev - the previous checked value
     * @param next - the current checked value
     *
     * @public
     */
    checkedChanged(prev, next) {
        if (typeof next === "boolean") {
            this.ariaChecked = next ? "true" : "false";
            return;
        }
        this.ariaChecked = null;
    }
    /**
     * Updates the proxy's text content when the default slot changes.
     * @param prev - the previous content value
     * @param next - the current content value
     *
     * @internal
     */
    contentChanged(prev, next) {
        if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.textContent = this.textContent;
        }
        this.$emit("contentchange", null, { bubbles: true });
    }
    defaultSelectedChanged() {
        if (!this.dirtySelected) {
            this.selected = this.defaultSelected;
            if (this.proxy instanceof HTMLOptionElement) {
                this.proxy.selected = this.defaultSelected;
            }
        }
    }
    disabledChanged(prev, next) {
        this.ariaDisabled = this.disabled ? "true" : "false";
        if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.disabled = this.disabled;
        }
    }
    selectedAttributeChanged() {
        this.defaultSelected = this.selectedAttribute;
        if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.defaultSelected = this.defaultSelected;
        }
    }
    selectedChanged() {
        this.ariaSelected = this.selected ? "true" : "false";
        if (!this.dirtySelected) {
            this.dirtySelected = true;
        }
        if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.selected = this.selected;
        }
    }
    initialValueChanged(previous, next) {
        // If the value is clean and the component is connected to the DOM
        // then set value equal to the attribute value.
        if (!this.dirtyValue) {
            this.value = this.initialValue;
            this.dirtyValue = false;
        }
    }
    get label() {
        var _a;
        return (_a = this.value) !== null && _a !== void 0 ? _a : this.text;
    }
    get text() {
        var _a, _b;
        return (_b = (_a = this.textContent) === null || _a === void 0 ? void 0 : _a.replace(/\s+/g, " ").trim()) !== null && _b !== void 0 ? _b : "";
    }
    set value(next) {
        const newValue = `${next !== null && next !== void 0 ? next : ""}`;
        this._value = newValue;
        this.dirtyValue = true;
        if (this.proxy instanceof HTMLOptionElement) {
            this.proxy.value = newValue;
        }
        Observable.notify(this, "value");
    }
    get value() {
        var _a;
        Observable.track(this, "value");
        return (_a = this._value) !== null && _a !== void 0 ? _a : this.text;
    }
    get form() {
        return this.proxy ? this.proxy.form : null;
    }
}
__decorate([
    observable
], ListboxOption$1.prototype, "checked", void 0);
__decorate([
    observable
], ListboxOption$1.prototype, "content", void 0);
__decorate([
    observable
], ListboxOption$1.prototype, "defaultSelected", void 0);
__decorate([
    attr({ mode: "boolean" })
], ListboxOption$1.prototype, "disabled", void 0);
__decorate([
    attr({ attribute: "selected", mode: "boolean" })
], ListboxOption$1.prototype, "selectedAttribute", void 0);
__decorate([
    observable
], ListboxOption$1.prototype, "selected", void 0);
__decorate([
    attr({ attribute: "value", mode: "fromView" })
], ListboxOption$1.prototype, "initialValue", void 0);
/**
 * States and properties relating to the ARIA `option` role.
 *
 * @public
 */
class DelegatesARIAListboxOption {
}
__decorate([
    observable
], DelegatesARIAListboxOption.prototype, "ariaChecked", void 0);
__decorate([
    observable
], DelegatesARIAListboxOption.prototype, "ariaPosInSet", void 0);
__decorate([
    observable
], DelegatesARIAListboxOption.prototype, "ariaSelected", void 0);
__decorate([
    observable
], DelegatesARIAListboxOption.prototype, "ariaSetSize", void 0);
applyMixins(DelegatesARIAListboxOption, ARIAGlobalStatesAndProperties);
applyMixins(ListboxOption$1, StartEnd, DelegatesARIAListboxOption);

class ListboxOption extends ListboxOption$1 {
  set text(value) {
    this._text = value;
  }
  get text() {
    var _a;
    return (_a = this._text) !== null && _a !== void 0 ? _a : '';
  }
  get label() {
    var _a;
    return (_a = this._label) !== null && _a !== void 0 ? _a : this.text;
  }
  set label(value) {
    this._label = value;
  }
}
__decorate([attr({
  attribute: 'text'
}), __metadata("design:type", String)], ListboxOption.prototype, "_text", void 0);
__decorate([attr({
  attribute: 'label'
}), __metadata("design:type", String)], ListboxOption.prototype, "_label", void 0);
applyMixins(ListboxOption, AffixIconWithTrailing);

let _ = t => t,
  _t,
  _t2;
const getClasses = ({
  icon,
  disabled,
  selected,
  checked
}) => classNames('base', ['disabled', disabled], ['selected', Boolean(selected)], ['active', Boolean(checked)], ['icon', Boolean(icon)]);
const ListboxOptionTemplate = context => {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html(_t || (_t = _`
	<template
		aria-checked="${0}"
		aria-disabled="${0}"
		aria-posinset="${0}"
		aria-selected="${0}"
		aria-setsize="${0}"
		role="option">
		<div class="${0}">
			${0}
			${0}
			${0}
		</div>
	</template>
	`), x => x.ariaChecked, x => x.ariaDisabled, x => x.ariaPosInSet, x => x.ariaSelected, x => x.ariaSetSize, getClasses, () => focusTemplate, x => affixIconTemplate(x.icon), when(x => x.text, html(_t2 || (_t2 = _`<div class="text">${0}</div>`), x => x.text)));
};

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n.base {\n  position: relative; /* this is needed for the focus */\n  display: flex;\n  box-sizing: border-box;\n  align-items: center;\n  background-color: var(--_appearance-color-fill);\n  border-radius: 6px;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  color: var(--_option-appearance-color-text, var(--_appearance-color-text));\n  font: var(--vvd-typography-base);\n  gap: 12px;\n  hyphens: auto;\n  inline-size: 100%;\n  min-block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n  padding-inline: 16px;\n  vertical-align: middle;\n  word-break: break-word;\n}\n.base {\n  --_connotation-color-primary: var(--vvd-color-canvas-text);\n  --_connotation-color-primary-text: var(--vvd-color-canvas);\n  --_connotation-color-primary-increment: var(--vvd-color-neutral-800);\n  --_connotation-color-faint: var(--vvd-color-neutral-50);\n  --_connotation-color-soft: var(--vvd-color-neutral-100);\n  --_connotation-color-pale: var(--vvd-color-neutral-300);\n  --_connotation-color-dim: var(--vvd-color-neutral-200);\n}\n.base {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:active, .active):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-soft);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:not(:disabled, .disabled, :hover, .hover)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-dim);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:hover, .hover) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-pale);\n  --_appearance-color-outline: transparent;\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  cursor: pointer;\n}\n.base.disabled {\n  cursor: not-allowed;\n  pointer-events: none;\n}\n.base .text {\n  font: var(--vvd-typography-base);\n}\n\n.icon {\n  font-size: 20px;\n  line-height: 1;\n}\n.base:not(.disabled, .selected) .icon {\n  color: var(--vvd-color-neutral-600);\n}\n\n.focus-indicator {\n  --focus-stroke-color: var(--vvd-color-neutral-500);\n  --focus-stroke-gap-color: transparent;\n}\n:host(:not([aria-checked=true])) .focus-indicator {\n  display: none;\n}";

const listboxOptionDefinition = ListboxOption.compose({
  baseName: 'option',
  template: ListboxOptionTemplate,
  styles: css_248z
});
const listboxOptionRegistries = [listboxOptionDefinition(), ...iconRegistries, ...focusRegistries];
const registerOption = registerFactory(listboxOptionRegistries);

export { listboxOptionDefinition as a, isListboxOption as i, listboxOptionRegistries as l, registerOption as r };
