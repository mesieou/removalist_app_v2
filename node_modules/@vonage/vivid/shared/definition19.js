import { Y as DOM, O as Observable, _ as __decorate, a as attr, o as observable, b as __metadata, h as html, r as registerFactory } from './index.js';
import { i as iconRegistries } from './definition3.js';
import { P as Popup, p as popupRegistries } from './definition20.js';
import { f as focusRegistries } from './definition4.js';
import { l as listboxOptionRegistries } from './definition21.js';
import { c as css_248z$1 } from './text-field.js';
import { b as AffixIcon, a as affixIconTemplateFactory } from './affix.js';
import './focus.js';
import { f as formElements } from './form-elements.js';
import { L as Listbox, D as DelegatesARIAListbox, a as Listbox$1 } from './listbox.js';
import { S as StartEnd } from './start-end.js';
import { S as SelectPosition } from './select.options.js';
import { a as applyMixins } from './apply-mixins.js';
import { F as FormAssociated } from './form-associated.js';
import { l as limit } from './numbers.js';
import { u as uniqueId } from './strings.js';
import { f as focusTemplateFactory } from './focus2.js';
import { s as slotted } from './slotted.js';
import { r as ref } from './ref.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

class _Combobox extends Listbox {
}
/**
 * A form-associated base class for the {@link (Combobox:class)} component.
 *
 * @internal
 */
class FormAssociatedCombobox extends FormAssociated(_Combobox) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
    }
}

/**
 * Autocomplete values for combobox.
 * @public
 */
const ComboboxAutocomplete = {
    inline: "inline",
    list: "list",
    both: "both",
    none: "none",
};

/**
 * A Combobox Custom HTML Element.
 * Implements the {@link https://w3c.github.io/aria-practices/#combobox | ARIA combobox }.
 *
 * @slot start - Content which can be provided before the input
 * @slot end - Content which can be provided after the input
 * @slot control - Used to replace the input element representing the combobox
 * @slot indicator - The visual indicator representing the expanded state
 * @slot - The default slot for the options
 * @csspart control - The wrapper element containing the input area, including start and end
 * @csspart selected-value - The input element representing the selected value
 * @csspart indicator - The element wrapping the indicator slot
 * @csspart listbox - The wrapper for the listbox slotted options
 * @fires change - Fires a custom 'change' event when the value updates
 *
 * @public
 */
class Combobox$1 extends FormAssociatedCombobox {
    constructor() {
        super(...arguments);
        /**
         * The internal value property.
         *
         * @internal
         */
        this._value = "";
        /**
         * The collection of currently filtered options.
         *
         * @public
         */
        this.filteredOptions = [];
        /**
         * The current filter value.
         *
         * @internal
         */
        this.filter = "";
        /**
         * The initial state of the position attribute.
         *
         * @internal
         */
        this.forcedPosition = false;
        /**
         * The unique id for the internal listbox element.
         *
         * @internal
         */
        this.listboxId = uniqueId("listbox-");
        /**
         * The max height for the listbox when opened.
         *
         * @internal
         */
        this.maxHeight = 0;
        /**
         * The open attribute.
         *
         * @public
         * @remarks
         * HTML Attribute: open
         */
        this.open = false;
    }
    /**
     * Reset the element to its first selectable option when its parent form is reset.
     *
     * @internal
     */
    formResetCallback() {
        super.formResetCallback();
        this.setDefaultSelectedOption();
        this.updateValue();
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate() {
        super.validate(this.control);
    }
    get isAutocompleteInline() {
        return (this.autocomplete === ComboboxAutocomplete.inline || this.isAutocompleteBoth);
    }
    get isAutocompleteList() {
        return this.autocomplete === ComboboxAutocomplete.list || this.isAutocompleteBoth;
    }
    get isAutocompleteBoth() {
        return this.autocomplete === ComboboxAutocomplete.both;
    }
    /**
     * Sets focus and synchronize ARIA attributes when the open property changes.
     *
     * @param prev - the previous open value
     * @param next - the current open value
     *
     * @internal
     */
    openChanged() {
        if (this.open) {
            this.ariaControls = this.listboxId;
            this.ariaExpanded = "true";
            this.setPositioning();
            this.focusAndScrollOptionIntoView();
            // focus is directed to the element when `open` is changed programmatically
            DOM.queueUpdate(() => this.focus());
            return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
    }
    /**
     * The list of options.
     *
     * @public
     * @remarks
     * Overrides `Listbox.options`.
     */
    get options() {
        Observable.track(this, "options");
        return this.filteredOptions.length ? this.filteredOptions : this._options;
    }
    set options(value) {
        this._options = value;
        Observable.notify(this, "options");
    }
    /**
     * Updates the placeholder on the proxy element.
     * @internal
     */
    placeholderChanged() {
        if (this.proxy instanceof HTMLInputElement) {
            this.proxy.placeholder = this.placeholder;
        }
    }
    positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
    }
    /**
     * The value property.
     *
     * @public
     */
    get value() {
        Observable.track(this, "value");
        return this._value;
    }
    set value(next) {
        var _a, _b, _c;
        const prev = `${this._value}`;
        if (this.$fastController.isConnected && this.options) {
            const selectedIndex = this.options.findIndex(el => el.text.toLowerCase() === next.toLowerCase());
            const prevSelectedValue = (_a = this.options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.text;
            const nextSelectedValue = (_b = this.options[selectedIndex]) === null || _b === void 0 ? void 0 : _b.text;
            this.selectedIndex =
                prevSelectedValue !== nextSelectedValue
                    ? selectedIndex
                    : this.selectedIndex;
            next = ((_c = this.firstSelectedOption) === null || _c === void 0 ? void 0 : _c.text) || next;
        }
        if (prev !== next) {
            this._value = next;
            super.valueChanged(prev, next);
            Observable.notify(this, "value");
        }
    }
    /**
     * Handle opening and closing the listbox when the combobox is clicked.
     *
     * @param e - the mouse event
     * @internal
     */
    clickHandler(e) {
        if (this.disabled) {
            return;
        }
        if (this.open) {
            const captured = e.target.closest(`option,[role=option]`);
            if (!captured || captured.disabled) {
                return;
            }
            this.selectedOptions = [captured];
            this.control.value = captured.text;
            this.clearSelectionRange();
            this.updateValue(true);
        }
        this.open = !this.open;
        if (this.open) {
            this.control.focus();
        }
        return true;
    }
    connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        if (this.value) {
            this.initialValue = this.value;
        }
    }
    /**
     * Synchronize the `aria-disabled` property when the `disabled` property changes.
     *
     * @param prev - The previous disabled value
     * @param next - The next disabled value
     *
     * @internal
     */
    disabledChanged(prev, next) {
        if (super.disabledChanged) {
            super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
    }
    /**
     * Filter available options by text value.
     *
     * @public
     */
    filterOptions() {
        if (!this.autocomplete || this.autocomplete === ComboboxAutocomplete.none) {
            this.filter = "";
        }
        const filter = this.filter.toLowerCase();
        this.filteredOptions = this._options.filter(o => o.text.toLowerCase().startsWith(this.filter.toLowerCase()));
        if (this.isAutocompleteList) {
            if (!this.filteredOptions.length && !filter) {
                this.filteredOptions = this._options;
            }
            this._options.forEach(o => {
                o.hidden = !this.filteredOptions.includes(o);
            });
        }
    }
    /**
     * Focus the control and scroll the first selected option into view.
     *
     * @internal
     * @remarks
     * Overrides: `Listbox.focusAndScrollOptionIntoView`
     */
    focusAndScrollOptionIntoView() {
        if (this.contains(document.activeElement)) {
            this.control.focus();
            if (this.firstSelectedOption) {
                requestAnimationFrame(() => {
                    var _a;
                    (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: "nearest" });
                });
            }
        }
    }
    /**
     * Handle focus state when the element or its children lose focus.
     *
     * @param e - The focus event
     * @internal
     */
    focusoutHandler(e) {
        this.syncValue();
        if (!this.open) {
            return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
            this.focus();
            return;
        }
        if (!this.options || !this.options.includes(focusTarget)) {
            this.open = false;
        }
    }
    /**
     * Handle content changes on the control input.
     *
     * @param e - the input event
     * @internal
     */
    inputHandler(e) {
        this.filter = this.control.value;
        this.filterOptions();
        if (!this.isAutocompleteInline) {
            this.selectedIndex = this.options
                .map(option => option.text)
                .indexOf(this.control.value);
        }
        if (e.inputType.includes("deleteContent") || !this.filter.length) {
            return true;
        }
        if (this.isAutocompleteList && !this.open) {
            this.open = true;
        }
        if (this.isAutocompleteInline) {
            if (this.filteredOptions.length) {
                this.selectedOptions = [this.filteredOptions[0]];
                this.selectedIndex = this.options.indexOf(this.firstSelectedOption);
                this.setInlineSelection();
            }
            else {
                this.selectedIndex = -1;
            }
        }
        return;
    }
    /**
     * Handle keydown actions for listbox navigation.
     *
     * @param e - the keyboard event
     * @internal
     */
    keydownHandler(e) {
        const key = e.key;
        if (e.ctrlKey || e.shiftKey) {
            return true;
        }
        switch (key) {
            case "Enter": {
                this.syncValue();
                if (this.isAutocompleteInline) {
                    this.filter = this.value;
                }
                this.open = false;
                this.clearSelectionRange();
                break;
            }
            case "Escape": {
                if (!this.isAutocompleteInline) {
                    this.selectedIndex = -1;
                }
                if (this.open) {
                    this.open = false;
                    break;
                }
                this.value = "";
                this.control.value = "";
                this.filter = "";
                this.filterOptions();
                break;
            }
            case "Tab": {
                this.setInputToSelection();
                if (!this.open) {
                    return true;
                }
                e.preventDefault();
                this.open = false;
                break;
            }
            case "ArrowUp":
            case "ArrowDown": {
                this.filterOptions();
                if (!this.open) {
                    this.open = true;
                    break;
                }
                if (this.filteredOptions.length > 0) {
                    super.keydownHandler(e);
                }
                if (this.isAutocompleteInline) {
                    this.setInlineSelection();
                }
                break;
            }
            default: {
                return true;
            }
        }
    }
    /**
     * Handle keyup actions for value input and text field manipulations.
     *
     * @param e - the keyboard event
     * @internal
     */
    keyupHandler(e) {
        const key = e.key;
        switch (key) {
            case "ArrowLeft":
            case "ArrowRight":
            case "Backspace":
            case "Delete":
            case "Home":
            case "End": {
                this.filter = this.control.value;
                this.selectedIndex = -1;
                this.filterOptions();
                break;
            }
        }
    }
    /**
     * Ensure that the selectedIndex is within the current allowable filtered range.
     *
     * @param prev - the previous selected index value
     * @param next - the current selected index value
     *
     * @internal
     */
    selectedIndexChanged(prev, next) {
        if (this.$fastController.isConnected) {
            next = limit(-1, this.options.length - 1, next);
            // we only want to call the super method when the selectedIndex is in range
            if (next !== this.selectedIndex) {
                this.selectedIndex = next;
                return;
            }
            super.selectedIndexChanged(prev, next);
        }
    }
    /**
     * Move focus to the previous selectable option.
     *
     * @internal
     * @remarks
     * Overrides `Listbox.selectPreviousOption`
     */
    selectPreviousOption() {
        if (!this.disabled && this.selectedIndex >= 0) {
            this.selectedIndex = this.selectedIndex - 1;
        }
    }
    /**
     * Set the default selected options at initialization or reset.
     *
     * @internal
     * @remarks
     * Overrides `Listbox.setDefaultSelectedOption`
     */
    setDefaultSelectedOption() {
        if (this.$fastController.isConnected && this.options) {
            const selectedIndex = this.options.findIndex(el => el.getAttribute("selected") !== null || el.selected);
            this.selectedIndex = selectedIndex;
            if (!this.dirtyValue && this.firstSelectedOption) {
                this.value = this.firstSelectedOption.text;
            }
            this.setSelectedOptions();
        }
    }
    /**
     * Focus and set the content of the control based on the first selected option.
     *
     * @internal
     */
    setInputToSelection() {
        if (this.firstSelectedOption) {
            this.control.value = this.firstSelectedOption.text;
            this.control.focus();
        }
    }
    /**
     * Focus, set and select the content of the control based on the first selected option.
     *
     * @internal
     */
    setInlineSelection() {
        if (this.firstSelectedOption) {
            this.setInputToSelection();
            this.control.setSelectionRange(this.filter.length, this.control.value.length, "backward");
        }
    }
    /**
     * Determines if a value update should involve emitting a change event, then updates the value.
     *
     * @internal
     */
    syncValue() {
        var _a;
        const newValue = this.selectedIndex > -1 ? (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text : this.control.value;
        this.updateValue(this.value !== newValue);
    }
    /**
     * Calculate and apply listbox positioning based on available viewport space.
     *
     * @param force - direction to force the listbox to display
     * @public
     */
    setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition
            ? this.positionAttribute
            : currentBox.top > availableBottom
                ? SelectPosition.above
                : SelectPosition.below;
        this.positionAttribute = this.forcedPosition
            ? this.positionAttribute
            : this.position;
        this.maxHeight =
            this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
    }
    /**
     * Ensure that the entire list of options is used when setting the selected property.
     *
     * @param prev - the previous list of selected options
     * @param next - the current list of selected options
     *
     * @internal
     * @remarks
     * Overrides: `Listbox.selectedOptionsChanged`
     */
    selectedOptionsChanged(prev, next) {
        if (this.$fastController.isConnected) {
            this._options.forEach(o => {
                o.selected = next.includes(o);
            });
        }
    }
    /**
     * Synchronize the form-associated proxy and update the value property of the element.
     *
     * @param prev - the previous collection of slotted option elements
     * @param next - the next collection of slotted option elements
     *
     * @internal
     */
    slottedOptionsChanged(prev, next) {
        super.slottedOptionsChanged(prev, next);
        this.updateValue();
    }
    /**
     * Sets the value and to match the first selected option.
     *
     * @param shouldEmit - if true, the change event will be emitted
     *
     * @internal
     */
    updateValue(shouldEmit) {
        var _a;
        if (this.$fastController.isConnected) {
            this.value = ((_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text) || this.control.value;
            this.control.value = this.value;
        }
        if (shouldEmit) {
            this.$emit("change");
        }
    }
    /**
     * @internal
     */
    clearSelectionRange() {
        const controlValueLength = this.control.value.length;
        this.control.setSelectionRange(controlValueLength, controlValueLength);
    }
}
__decorate([
    attr({ attribute: "autocomplete", mode: "fromView" })
], Combobox$1.prototype, "autocomplete", void 0);
__decorate([
    observable
], Combobox$1.prototype, "maxHeight", void 0);
__decorate([
    attr({ attribute: "open", mode: "boolean" })
], Combobox$1.prototype, "open", void 0);
__decorate([
    attr
], Combobox$1.prototype, "placeholder", void 0);
__decorate([
    attr({ attribute: "position" })
], Combobox$1.prototype, "positionAttribute", void 0);
__decorate([
    observable
], Combobox$1.prototype, "position", void 0);
/**
 * Includes ARIA states and properties relating to the ARIA combobox role.
 *
 * @public
 */
class DelegatesARIACombobox {
}
__decorate([
    observable
], DelegatesARIACombobox.prototype, "ariaAutoComplete", void 0);
__decorate([
    observable
], DelegatesARIACombobox.prototype, "ariaControls", void 0);
applyMixins(DelegatesARIACombobox, DelegatesARIAListbox);
applyMixins(Combobox$1, StartEnd, DelegatesARIACombobox);

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n:host {\n  position: relative;\n}\n\n.control {\n  display: flex;\n  padding-inline-end: 44px;\n}\n\n.icon {\n  inset-inline-end: 16px;\n  inset-inline-start: unset;\n}\n:not(.disabled) .icon {\n  cursor: pointer;\n}\n.disabled .icon {\n  cursor: not-allowed;\n}\n\n.listbox {\n  padding: 4px;\n  background-color: var(--_appearance-color-fill);\n  border-radius: 6px;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  contain: paint;\n}\n.listbox {\n  --_connotation-color-backdrop: var(--vvd-color-canvas);\n  --_connotation-color-intermediate: var(--vvd-color-neutral-500);\n  --_connotation-color-primary: var(--vvd-color-canvas-text);\n  --_connotation-color-soft: var(--vvd-color-neutral-100);\n}\n.listbox {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.listbox.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.listbox:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.listbox:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-400);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n\n::part(popup-base) {\n  inline-size: 100%;\n}";

let Combobox = class Combobox extends Combobox$1 {
  connectedCallback() {
    super.connectedCallback();
    this._popup.anchor = this._anchor;
  }
};
__decorate([attr, __metadata("design:type", String)], Combobox.prototype, "placement", void 0);
Combobox = __decorate([formElements], Combobox);
applyMixins(Combobox, AffixIcon);

let _ = t => t,
  _t,
  _t2,
  _t3;
function renderLabel() {
  return html(_t || (_t = _`
	  <label for="control" class="label">
		  ${0}
	  </label>`), x => x.label);
}
const getStateClasses = ({
  disabled,
  placeholder,
  label
}) => classNames('base', ['disabled', disabled], ['placeholder', Boolean(placeholder)], ['no-label', !label]);
function renderInput(context) {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html(_t2 || (_t2 = _`
		<div class="${0}" ${0}>
			${0}
			<div class="fieldset">
				<input
					id="control"
					class="control"
					aria-activedescendant="${0}"
					aria-autocomplete="${0}"
					aria-controls="${0}"
					aria-disabled="${0}"
					aria-expanded="${0}"
					aria-haspopup="listbox"
					placeholder="${0}"
					role="combobox"
					type="text"
					?disabled="${0}"
					:value="${0}"
					@input="${0}"
					@keyup="${0}"
					${0}
				/>
				${0}
				${0}
			</div>
		</div>`), getStateClasses, ref('_anchor'), when(x => x.label, renderLabel()), x => x.open ? x.ariaActiveDescendant : null, x => x.ariaAutoComplete, x => x.ariaControls, x => x.ariaDisabled, x => x.ariaExpanded, x => x.placeholder, x => x.disabled, x => x.value, (x, c) => x.inputHandler(c.event), (x, c) => x.keyupHandler(c.event), ref('control'), () => affixIconTemplate('chevron-down-line'), () => focusTemplate);
}
const comboboxTemplate = context => {
  const popupTag = context.tagFor(Popup);
  return html(_t3 || (_t3 = _`
        <template
            aria-disabled="${0}"
            autocomplete="${0}"
            tabindex="${0}"
            @click="${0}"
            @focusout="${0}"
            @keydown="${0}"
        >
			${0}
			<${0} class="popup"
				?open="${0}"
				placement="${0}"
				strategy="absolute"
				${0}>
				<div id="${0}"
					class="listbox"
					role="listbox"
					?disabled="${0}"
					${0}>
					<slot ${0}>
					</slot>
				</div>
			</${0}>
        </template>
		`), x => x.ariaDisabled, x => x.autocomplete, x => !x.disabled ? '0' : null, (x, c) => x.clickHandler(c.event), (x, c) => x.focusoutHandler(c.event), (x, c) => x.keydownHandler(c.event), () => renderInput(context), popupTag, x => x.open, x => x.placement, ref('_popup'), x => x.listboxId, x => x.disabled, ref('listbox'), slotted({
    filter: Listbox$1.slottedOptionFilter,
    flatten: true,
    property: 'slottedOptions'
  }), popupTag);
};

const combobox = Combobox.compose({
  baseName: 'combobox',
  template: comboboxTemplate,
  styles: [css_248z$1, css_248z],
  shadowOptions: {
    delegatesFocus: true
  }
})();
const comboboxRegistries = [combobox, ...iconRegistries, ...popupRegistries, ...focusRegistries, ...listboxOptionRegistries];
const registerCombobox = registerFactory(comboboxRegistries);

export { comboboxRegistries as a, combobox as c, registerCombobox as r };
