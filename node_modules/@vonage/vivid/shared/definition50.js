import { l as fails$5, g as global$3, K as functionCall, k as functionUncurryThis, a9 as shared$1, aa as objectCreate, L as internalState, G as _export, w as wellKnownSymbol$2, H as defineBuiltIn$1, ab as createNonEnumerableProperty$1, T as requireObjectCoercible$2, ac as toIntegerOrInfinity$2, a2 as toObject$1, q as anObject$2, m as isCallable$2, c as classofRaw, s as isNullOrUndefined$1, ad as toLength$1, P as getMethod$1, F as FoundationElement, Y as DOM, U as __classPrivateFieldGet, W as __classPrivateFieldSet, _ as __decorate, a as attr, b as __metadata, h as html, r as registerFactory } from './index.js';
import { P as Popup, p as popupRegistries } from './definition20.js';
import { r as regexpFlags$1 } from './es.regexp.to-string.js';
import { t as toString$3 } from './to-string.js';
import { f as functionUncurryThisClause, a as functionApply } from './icon.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

var css_248z = "/**\n * Do not edit directly\n * Generated on Wed, 17 May 2023 03:28:45 GMT\n */\n.control {\n  display: inline-block;\n}\n\n.content-wrapper {\n  width: var(--toggletip-inline-size, auto);\n  padding: 16px;\n}\n\n.headline {\n  font: var(--vvd-typography-base-bold);\n}\n\n.action-items {\n  display: flex;\n  justify-content: flex-end;\n  gap: 10px;\n}\n\n::slotted([slot=action-items]) {\n  margin-block-start: 16px;\n}";

var fails$4 = fails$5;
var global$2 = global$3;

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp$2 = global$2.RegExp;

var UNSUPPORTED_Y$1 = fails$4(function () {
  var re = $RegExp$2('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function () {
  return !$RegExp$2('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp$2('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

var regexpStickyHelpers = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$1
};

var fails$3 = fails$5;
var global$1 = global$3;

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp$1 = global$1.RegExp;

var regexpUnsupportedDotAll = fails$3(function () {
  var re = $RegExp$1('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});

var fails$2 = fails$5;
var global = global$3;

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

var regexpUnsupportedNcg = fails$2(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call$2 = functionCall;
var uncurryThis$4 = functionUncurryThis;
var toString$2 = toString$3;
var regexpFlags = regexpFlags$1;
var stickyHelpers = regexpStickyHelpers;
var shared = shared$1.exports;
var create = objectCreate;
var getInternalState = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$3 = uncurryThis$4(''.charAt);
var indexOf = uncurryThis$4(''.indexOf);
var replace$1 = uncurryThis$4(''.replace);
var stringSlice$3 = uncurryThis$4(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call$2(nativeExec, re1, 'a');
  call$2(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString$2(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call$2(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call$2(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace$1(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice$3(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call$2(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice$3(match.input, charsAdded);
        match[0] = stringSlice$3(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call$2(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

var regexpExec$2 = patchedExec;

var $ = _export;
var exec = regexpExec$2;

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});

// TODO: Remove from `core-js@4` since it's moved to entry points

var uncurryThis$3 = functionUncurryThisClause;
var defineBuiltIn = defineBuiltIn$1;
var regexpExec$1 = regexpExec$2;
var fails$1 = fails$5;
var wellKnownSymbol$1 = wellKnownSymbol$2;
var createNonEnumerableProperty = createNonEnumerableProperty$1;

var SPECIES = wellKnownSymbol$1('species');
var RegExpPrototype = RegExp.prototype;

var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol$1(KEY);

  var DELEGATES_TO_SYMBOL = !fails$1(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var uncurriedNativeRegExpMethod = uncurryThis$3(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$3(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};

var uncurryThis$2 = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var toString$1 = toString$3;
var requireObjectCoercible$1 = requireObjectCoercible$2;

var charAt$2 = uncurryThis$2(''.charAt);
var charCodeAt = uncurryThis$2(''.charCodeAt);
var stringSlice$2 = uncurryThis$2(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$1(requireObjectCoercible$1($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt$2(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice$2(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

var charAt$1 = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
var advanceStringIndex$1 = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};

var uncurryThis$1 = functionUncurryThis;
var toObject = toObject$1;

var floor = Math.floor;
var charAt = uncurryThis$1(''.charAt);
var replace = uncurryThis$1(''.replace);
var stringSlice$1 = uncurryThis$1(''.slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice$1(str, 0, position);
      case "'": return stringSlice$1(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice$1(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};

var call$1 = functionCall;
var anObject$1 = anObject$2;
var isCallable$1 = isCallable$2;
var classof = classofRaw;
var regexpExec = regexpExec$2;

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (isCallable$1(exec)) {
    var result = call$1(exec, R, S);
    if (result !== null) anObject$1(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call$1(regexpExec, R, S);
  throw $TypeError('RegExp#exec called on incompatible receiver');
};

var apply = functionApply;
var call = functionCall;
var uncurryThis = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var fails = fails$5;
var anObject = anObject$2;
var isCallable = isCallable$2;
var isNullOrUndefined = isNullOrUndefined$1;
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var toLength = toLength$1;
var toString = toString$3;
var requireObjectCoercible = requireObjectCoercible$2;
var advanceStringIndex = advanceStringIndex$1;
var getMethod = getMethod$1;
var getSubstitution = getSubstitution$1;
var regExpExec = regexpExecAbstract;
var wellKnownSymbol = wellKnownSymbol$2;

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          var replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

var _Toggletip_instances, _Toggletip_anchorEl, _Toggletip_ANCHOR_ARIA_LABEL_SUFFIX, _Toggletip_setupAnchor, _Toggletip_cleanupAnchor, _Toggletip_openIfClosed, _Toggletip_closeOnClickOutside, _Toggletip_closeOnEscape;
class Toggletip extends FoundationElement {
  constructor() {
    super(...arguments);
    _Toggletip_instances.add(this);
    _Toggletip_anchorEl.set(this, null);
    _Toggletip_ANCHOR_ARIA_LABEL_SUFFIX.set(this, ' ; Show more information');
    this.alternate = false;
    this.placement = 'right';
    this.anchor = '';
    this.open = false;
    _Toggletip_openIfClosed.set(this, () => {
      if (!this.open) DOM.queueUpdate(() => this.open = true);
    });
    _Toggletip_closeOnClickOutside.set(this, e => {
      if (!this.contains(e.target)) this.open = false;
    });
    _Toggletip_closeOnEscape.set(this, e => {
      if (e.key === 'Escape') this.open = false;
    });
  }
  anchorChanged(_, newValue) {
    if (__classPrivateFieldGet(this, _Toggletip_anchorEl, "f")) __classPrivateFieldGet(this, _Toggletip_instances, "m", _Toggletip_cleanupAnchor).call(this, __classPrivateFieldGet(this, _Toggletip_anchorEl, "f"));
    __classPrivateFieldSet(this, _Toggletip_anchorEl, newValue instanceof HTMLElement ? newValue : document.getElementById(newValue), "f");
    if (__classPrivateFieldGet(this, _Toggletip_anchorEl, "f")) __classPrivateFieldGet(this, _Toggletip_instances, "m", _Toggletip_setupAnchor).call(this, __classPrivateFieldGet(this, _Toggletip_anchorEl, "f"));
  }
  openChanged(oldValue, newValue) {
    if (oldValue === undefined) return;
    if (newValue) {
      document.addEventListener('click', __classPrivateFieldGet(this, _Toggletip_closeOnClickOutside, "f"));
      document.addEventListener('keydown', __classPrivateFieldGet(this, _Toggletip_closeOnEscape, "f"));
      this.setAttribute('role', 'status');
    } else {
      document.removeEventListener('click', __classPrivateFieldGet(this, _Toggletip_closeOnClickOutside, "f"));
      document.removeEventListener('keydown', __classPrivateFieldGet(this, _Toggletip_closeOnEscape, "f"));
      this.removeAttribute('role');
    }
    if (__classPrivateFieldGet(this, _Toggletip_anchorEl, "f")) {
      __classPrivateFieldGet(this, _Toggletip_anchorEl, "f").ariaExpanded = this.open.toString();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (__classPrivateFieldGet(this, _Toggletip_anchorEl, "f")) __classPrivateFieldGet(this, _Toggletip_instances, "m", _Toggletip_cleanupAnchor).call(this, __classPrivateFieldGet(this, _Toggletip_anchorEl, "f"));
    document.removeEventListener('keydown', __classPrivateFieldGet(this, _Toggletip_closeOnEscape, "f"));
  }
}
_Toggletip_anchorEl = new WeakMap(), _Toggletip_ANCHOR_ARIA_LABEL_SUFFIX = new WeakMap(), _Toggletip_openIfClosed = new WeakMap(), _Toggletip_closeOnClickOutside = new WeakMap(), _Toggletip_closeOnEscape = new WeakMap(), _Toggletip_instances = new WeakSet(), _Toggletip_setupAnchor = function _Toggletip_setupAnchor(a) {
  var _a;
  a.addEventListener('click', __classPrivateFieldGet(this, _Toggletip_openIfClosed, "f"), true);
  a.ariaLabel = ((_a = a.ariaLabel) !== null && _a !== void 0 ? _a : '') + __classPrivateFieldGet(this, _Toggletip_ANCHOR_ARIA_LABEL_SUFFIX, "f");
}, _Toggletip_cleanupAnchor = function _Toggletip_cleanupAnchor(a) {
  a.removeEventListener('click', __classPrivateFieldGet(this, _Toggletip_openIfClosed, "f"), true);
  if (a.ariaLabel) a.ariaLabel = a.ariaLabel.replace(__classPrivateFieldGet(this, _Toggletip_ANCHOR_ARIA_LABEL_SUFFIX, "f"), '');
};
__decorate([attr, __metadata("design:type", String)], Toggletip.prototype, "headline", void 0);
__decorate([attr({
  mode: 'boolean'
}), __metadata("design:type", Object)], Toggletip.prototype, "alternate", void 0);
__decorate([attr({
  mode: 'fromView'
}), __metadata("design:type", String)], Toggletip.prototype, "placement", void 0);
__decorate([attr({
  mode: 'fromView'
}), __metadata("design:type", Object)], Toggletip.prototype, "anchor", void 0);
__decorate([attr({
  mode: 'boolean'
}), __metadata("design:type", Object)], Toggletip.prototype, "open", void 0);

let _2 = t => t,
  _t,
  _t2;
const getClasses = _ => classNames('control');
const ToggletipTemplate = context => {
  const popup = context.tagFor(Popup);
  return html(_t || (_t = _2`
		<${0}
			class="${0}"
			arrow
			:anchor="${0}"
			:open="${0}"
			?alternate="${0}"
			placement="${0}"
			exportparts="vvd-theme-alternate"
		>
			<div class="content-wrapper">
				${0}
				<slot></slot>
				<footer class="action-items"><slot name="action-items"></slot></footer>
			</div>
		</${0}>
	`), popup, getClasses, x => x.anchor, x => x.open, x => !x.alternate, x => x.placement, when(x => x.headline, html(_t2 || (_t2 = _2`<header class="headline">${0}</header>`), x => x.headline)), popup);
};

const toggletipDefinition = Toggletip.compose({
  baseName: 'toggletip',
  template: ToggletipTemplate,
  styles: css_248z
});
const toggletipRegistries = [toggletipDefinition(), ...popupRegistries];
const registerToggletip = registerFactory(toggletipRegistries);

export { toggletipRegistries as a, registerToggletip as r, toggletipDefinition as t };
